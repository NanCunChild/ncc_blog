---
title: "Pokapoka搞破坏————记MifareClassic卡渗透实操"
date: 2026-02-18T23:59:53+08:00
draft: false
toc: false
images:
tags:
  - tech
  - pokapoka
description: "敲击敲击IC卡"
---


## Pokapoka栏目统一警告

本栏目所有文章仅供安全研究与技术交流，漏洞已反馈或测试仅限于本人授权范围内的设备。
请勿尝试修改他人房卡或进入未授权区域，否则可能触犯法律。

## 前情提要

NCC来到酒店，想要在自己出去的一个小时中仍然让空调开着，这样回来就能有最舒适的温度啦。可惜现在酒店的插卡取电装置都使用了读卡器，而不是以前很简单的光探测开关，如果把唯一一张卡放在那里，那NCC就进不去啦。

盯着手上的那张房卡，NCC想到了好方法，使用NFC复制！把内容都读取出来，然后模拟卡。

## IC卡前置知识

别被术语绕晕：卡片技术分级
​市面上的卡片和称呼五花八门（ID、IC、RFID……），为了看清本质，我们可以按安全等级或者发展历史将它们分为三类：
​
- 只读存储卡 (RO Memory Card)

	- ​代表：磁条卡 (Magnetic Stripe Card) / 只读存储卡 (RO Memory Card)。

  	- ​原理：静态明文存储，类似录音带，数据明文记录。

	- ​安全性：易被 **侧信道攻击** 或 **重放攻击** 。

-  非接触式逻辑加密卡 (Contactless Memory Card)

    - 代表：Mifare Classic (M1)、HID iCLASS Legacy。

	- ​特征：遵循 **ISO 14443 Type A** 协议（部分）。

	- ​原理：卡内有存储区和简单的逻辑电路。使用专有的 **Crypto-1** 流加密算法。它的本质依然是“存储器”，只是在读写前加了一道“口令验证”。

	- ​安全性：验证漏洞，noise分析逆向，硬嵌套攻击。

- 双界面CPU卡 (Dual Interface CPU Card)
	- ​代表：身份证、银行 IC 卡、Mifare DESFire。

	- ​特征：内置微型单片机（MCU）甚至操作系统（COS）。

    - 原理：挑战-响应机制，不是“被读取”，而是“在对话”。读卡器发随机数（Challenge），卡片用私钥计算后回传结果（Response），私钥永不出卡。

    - 安全性：极高，目前基本无法通过“复制”破解。方向需要转向芯片漏洞或者攻击服务器来拿到密钥而不是卡本身。

### 深入 Mifare Classic 1K (S50)

既然NCC决定动手Hack，那就必须了解我们手中的“靶子”到底长什么样。Mifare Classic 1K（简称M1卡）不仅是酒店房卡，也是很多门禁卡、饭卡的前身。

#### 1. 地图全貌：存储结构 (Memory Structure)

这就好比一个有16个抽屉的柜子，每个抽屉里有4个小盒子。

- **总容量**：1024 字节 (1KB)。

- **分区 (Sectors)**：共有 **16个扇区** (Sector 0 - Sector 15)。

- **区块 (Blocks)**：每个扇区有 **4个区块** (Block 0 - Block 3)，每个区块 **16字节**。

**特别注意这两个特殊区域：**

- **Sector 0, Block 0 (厂商块/Manufacturer Block)**：

    - 这是卡片的“身份证”。包含唯一标识符和厂商数据。

    - **出厂固化**：在正规卡上，这里是**只读**的。

    - **黑客特供**：市面上的“UID卡”或“CUID卡”可以通过特殊指令修改这里，从而完美克隆一张卡片的ID。

- **每个扇区的 Block 3 (尾块/Sector Trailer)**：

    - 这是每个扇区的“控制室”。绝对不能乱写，否则扇区会锁死变砖。

    - 结构如下： `[ Key A (6字节) ] [ 存取控制位 (4字节) ] [ Key B (6字节) ]`

#### 2. 加密与验证：Crypto-1 协议

M1卡不像U盘插上就能读，它和读卡器之间有一个“对暗号”的过程。

- **算法**：**Crypto-1**。这是一个私有的流加密算法。

- **流程**：

    1. 读卡器呼叫卡片。

    2. 卡片发送随机数（Challenge）。

    3. 读卡器用密钥（Key A或Key B）加密这个随机数并寄回。

    4. 卡片验证，如果正确，双方建立加密通道。

- **漏洞**：NCC使用的 Flipper Zero 之所以能秒解，是因为Crypto-1算法的随机数生成器（PRNG）极其脆弱。通过 **Nested Attack ** 或 **Darkside Attack**，可以在不知道密码的情况下，利用漏洞反推密钥。

#### 3. 核心机制：存取控制位 (Access Bits)

在每个扇区的 Block 3 中，中间那 4 个字节决定了谁有资格读写数据。

- **默认值**：`FF 07 80 69`

    - 这意味着：Key A 是万能钥匙（可读写所有数据，可修改Key B），Key B 也是万能的。

- **危险操作**：控制位有冗余校验机制（正反存）。如果你算错了控制位并写入，这个扇区就会**永久锁死**，再也无法认证（这就是传说中的“写死卡”）。

#### 4. 校验位规则详解 (The Checksum Rules)

这是NCC最关心的部分。卡片里其实藏着两层校验：

**(1) 物理层校验：BCC (Block Check Character)** 这位于 **Sector 0, Block 0** 的第 5 个字节。它的作用是验证 UID 是否传输出错。

- **规则**：**异或校验 (XOR Checksum)**。

- **公式**：`UID0 ^ UID1 ^ UID2 ^ UID3 = BCC`

- **例子**：如果 UID 是 `11 22 33 44`，那么 BCC = `11 ^ 22 ^ 33 ^ 44`。如果不符合这个规则，读卡器连理都不理这张卡。

既然有13个扇区，那有很多空间放东西，可以弱水三千只取一瓢饮，只用一个扇区，也可以全部扇区都用上。为了工程上的方便，往往只用一个扇区，重要信息再加密一下。

## Pokapoka

使用flipper zero的NFC读取功能往上面一放，发现它马上通过默认密码找到了几乎所有扇区的密钥并解密了数据。但是对于11扇区却遍历了整个小词典也没找到，看来不是各种大厂家的常用密码，接下来我们要通过攻击读卡器来尝试抓取读卡器找卡要11扇区内容时请求是什么。

```text
MF Classic System Dictionary
Unlocking sector: 11
---1860/3824---
Keys found: 30/32
Sectors Read: 15/16
@ Skip
```

在decrypt failed界面按一下skip，然后会有一个extract选项，选中它，然后靠近读卡器进行抓包，抓到之后为了速度就直接传到手机上进行解密，目前手机算力已经能轻松应对这种运算了。5秒左右就能完成解算，如果让flipper zero本地运算则需要大约20分钟。解算完成后会提示已将密钥放入词典（吐槽这个功能，怎么什么都往词典里放，整的卡多了会变慢，太不优雅了）。
完成后，再次使用NFC读取功能靠近卡片，此时会提示全部解密成功。整个卡的数据完全拿到，可以进行emulate功能冒充房卡了。

```text
Mfkey32 (Extract MF Keys)
1 New Key added to User Dict.

89E65C89E65C

Done

Calculated Keys (5)
Sector 11 - Key A - 89E65C89E65C
Sector 11 - Key A - 89E65C89E65C
Sector 11 - Key A - 89E65C89E65C
Sector 11 - Key A - 89E65C89E65C
Sector 11 - Key A - 89E65C89E65C

Unique (1)

89E65C89E65C
```

接下来可以找一个空白UID卡直接使用flipper zero进行写入，不过身上没有携带这个（下次得记得至少带两张），于是转向另一个方向：逆向内容。
dump一下数据，抓到的内容如下：

```text
Sector: 10
40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
41 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
42 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
43 FF FF FF FF FF FF FF 07 80 69 FF FF FF FF FF FF

Sector: 11
44 A4 2D 27 F1 EE 02 91 6B 00 00 00 00 00 00 00 00
45 00 21 1A 02 05 0F 30 1A 02 06 0F 00 08 03 09 00
46 00 00 00 00 00 00 00 00 00 00 00 00 00 E6 5C AA
47 89 E6 5C 89 E6 5C 78 77 88 69 ?? ?? ?? ?? ?? ??

Sector: 12
48 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
49 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
50 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
51 FF FF FF FF FF FF FF 07 80 69 FF FF FF FF FF FF
```

NCC住在309号房间，订房日期为2026年2月5日到6日，能看到44区块应该是卡的相关ID，以及住房软件的配套识别ID。
观察45区块， Hex 数据 `1A 02 05`，这显然采用了BCD 编码，对应日期 `26-02-05`。紧随其后的 `08 03 09` 则直接映射了楼层信息为8楼309室。

值得注意的是 Block 46 的数据结构。在修改了日期数据后，若直接写入卡片通常会导致刷卡失败，这暗示 Block 46 存储了用于完整性验证的校验和。如果真的要免费续住或者弄出万能卡，需要分析更多样本或者逆向管理软件重算校验位完成完美伪造。

第47区块的为key A，这里还能看到内容就是 *89 E6 5C 89 E6 5C* ，三个字节重复了一次（这都要偷懒），随后三位 *78 77 88* 为存取控制位，确定能读取和修改什么，它的规则是“读取鉴权位”-“存储鉴权位”-“密码修改鉴权位”。

我们可以合理推断，改动这个2月6日的终止日期就可以让我有一个这个房间的永久卡。修改房间地址就可以打开任意房间的门，这让我有点想起我之前玩的名叫「else heart.break()」游戏，弄清了世界原理，所有的门都是敞开的啦。
